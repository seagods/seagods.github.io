<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name=Description" content="Getting Started With CGI"><br/>
<title>Chris Godsalve's Getting Started With CGI</title>

<style type="text/css">
@import url(cochise.css);
</style>

</head>
<!-- Background white, links blue (unvisited), navy (visited), red
(active) -->
<body>


<blockquote> Copyright &copy 2004 C. Godsalve, all rights reserved.</blockquote> <br clear="all" />

<h1 align="center"> <a name="begin">Getting Started With CGI </a> </h1>

<ul>
<li> <a href="#Intro" > Introduction </a></li>
<li> <a href="#Hello" > Hello World </a> </li>
<li> <a href="#forms1" > Processing Forms </a> </li>
<li> <a href="#mail1" > Sending Mail through CGI </a> </li>
<li> <a href="#forms2" > More on Forms </a> </li>

</ul>

<blockquote>

<h1 align="center"> <a name="intro">Introduction</a> </h1>
<p>
CGI stands for Common Gateway interface. This is the interface between your programmes and your web-server. The programmes
might be precompiled binaries generated by a C++ or FORTRAN code, or they might be run as Perl, java, php, or python scripts. So, you write
your programmes in whatever language you want.  All the examples here are written in <a href="Perl.html"> Perl</a>. Note
that I am writing this as a few notes to myself, this might not be quite what <em>you </em> want, if not there's plenty more
out there on the web.</p>

<p>
So, what would you use CGI for? If you want dynamic HTML, so that what appears
on that web page depends on the previous viewer's input, or if you want to run a web chess game on your browser, or if your web pages contain forms to be filled
in and the input is to be read and mailed to you, you need CGI to do it.
</p>

<p>
But before we start, why (if at all) do you need to run CGI scripts? First of all, where are your web pages? For instance, if you're
on a free web hosting service, it's unlikely that your pages are CGI enabled. OK, the message board or whatever limited
CGI bits and bobs that you can use, will be CGI scripts, but you yourself can't upload your CGI scripts and run them. You may have
to pay to upgrade your service, so you should look around and see what's available. If you want to run CGI at work, check it out with the systems administrator. Obviously, your (whatever host service) site runs a web server, but does your system at work? CGI files are run by
whatever web server is running on the system. If there is no web-server on the system, get one for free. Most people would recommend
<a href="http://www.apache.org"> Apache </a>. So, even if you don't have CGI enabled web pages out there, you can write and test
CGI scripts on your own machine by downloading Apache and installing it. (If you are on a PC with a Linux
operating system, it will be on the install discs if not installed already.) Once you have it running, you will see a default page
if you type http://localhost/  or http://127.0.0.1 into your browser's address bar. That's your web server serving you an
HTML document for the first time.
Change the index file to whatever you want. (I am assuming you know HTML, if not, there are plenty of easy tutorials on the web, and the local
library almost certainly has several books on how to write HTML.)
 </p>

 <p>
I shall assume your web-server is Apache, if your web pages are on freewebs say, you will have to find out how to do all this
from freewebs. At any rate, if you installed Apache, somewhere there is a directory called CGI-bin. On my system it's /srv/www/cgi-bin, it will be different depending on the exact operating system you have. All the CGI programmes should live here. (You <em> can </em> have them
all over the place, but for security reasons, keeping them all here is a good idea. Never have any CGI scripts mixed in with your HTML stuff.)
On my system, the HTML files all go in /srv/www/htdocs and whatever sub-directories that I've made in it. There is an important
file called httpd.conf. Again, on my system it's in /etc/apache2, it will probably be in a different place for you. This has to be edited if you want to run CGI scripts. You need to add
something like <br/> <br />

ScriptAlias /cgi-bin/ "/srv/www/cgi-bin/" <br />
AddHandler cgi-script cgi <br />
AddHandler cgi-script pl <br />
&lt Directory /srv/www/cgi-bin/ &gt <br />
Options +ExecCGI <br />
&lt /Directory &gt <br /> <br />

The first line makes the web server understand that when it sees cgi-bin that it's actually /srv/www/cgi-bin. Next, we get
the server to to be able to handle files with cgi or pl extensions. (It could be any extension that you save your CGI
programme with. Finally, we tell the web server that it is allowed to execute CGI programmes that are in the directory /srv/www/cgi-bin. If you're not just testing stuff out,
 and other people are going to access your server, put the line "ServerAdmin youradress@whatever.com" after this.



<br/> <a href="#begin"> Back to list of contents </a>
</p>
</blockquote>

<h1 align="center"><a name="Hello"> Hello World </a></h1>


<p>
<blockquote>
Here is the ubiquitous Hello.pl,  except it's saved with the dot cgi extension. (Since we have pl in the Apache AddHandler list, we could save
our files with the dot pl extension too.)</br> <br/>
<br/></br/>
#!/usr/bin/Perl <br/>
print qq(Content-type: text/html\n\n);<br/>
print qq(&lt html &gt &lt head &gt &lt title &gt   Hello World &lt /title &gt   &lt /head &gt \n);<br/>
print qq( &lt body&gt \n);<br/>
print qq(&lt h1&gt Hello, world &lt /h1&gt\n);<br/>
print qq(&lt p &gt This is CGI! &lt/p &gt\n);<br/>
print qq(&lt /body &gt &lt /html &gt \n);<br/><br/>

OK, this just runs as a Perl script right? if you type in "Perl Hello.cgi" at the command line, it writes out to the screen. Now, we create an html file that looks something like <br clear="all"/><br/>
    &lt ?xml version="1.0" encoding="iso-8859-1"?&gt<br/>
&lt !DOCTYPE html<br/>
	PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"<br/>
	 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" &gt <br/>
&lthtml xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" &gt <br/>
&lt head &gt &lt title &gt Hello World &lt/title &gt <br/>
&lt /head &gt body &gt <br/>
&lt  a href="http://localhost/cgi-bin/Hello.cgi" &gt  Click Me! &lt /a &gt <br/>
&lt /body &gt <br/>
 &lt /html &gt
 <br/><br/>
 (The qq saves on backslashes for meta characters).
If you bring it up in the browser, there is just a single link that says Click Me! Now, you have to put your Perl script into
the cgi-bin. If you are on a unix/linux machine, you must change to root and then have give read and execute permissions on the Hello.cgi file to user, group, and others (chmod ugo+rx Hello.cgi). You click on the link, and the browser executes the Hello.cgi file, the output
of the CGI programme now goes to the browser not the screen. Any text output going to the browser <em>must</em> be preceded with that content-type statement. The browser
reads the output from the programme just as it reads the text in your html documents, and brings up the page. That's basically what CGI does.


Now this would get tedious if we were writing a big html files, all those print statements! However, perl's print statement can
print multiple lines using an end marker. In this example, it's EndofHTML.<br/><br/>

!/usr/bin/Perl<br/>
use CGI qw(:standard);<br/>
print "Content-type: text/html\n\n";<br/>
print &lt &lt EndOfHTML;<br/>
 &lt html> &lt head &gt &lt title>Hello World &lt /title &gt  &lt /head &gt <br/>
 &lt body &gt <br/>
 &lt h1>Hello world, this is CGI &lt /h1 &gt <br/>
 &lt /body> &lt /html &gt <br/>
EndOfHTML<br/><br/>

So if you already have an html file, you just cut and paste. This time, we have sneaked in "use CGI", this means that we
are using the CGI.pm module's standard functions, except we're not using it yet. Lets use some now, try<br/><br/>

#!/usr/bin/Perl<br/>
use CGI qw(:standard);<br/>
print header;<br/>
print start_html("My title is Hello World");<br/>
print &lt &lt EndOfHTML;<br/>
 &lt h2 &gt Hello world, this is CGI &lt /h2 &gt <br/>
EndOfHTML<br/>
print end_html\n;<br/>
print qq(end_html adds the  &lt /body &gt  stuff\n);<br/>
print "\n";<br/>
<br/>
A string containing the content type bit is returned by header function, the start of the html file is returned by start_html("some string"), the string is written into the html title, and the end_html func
the last CGI function, end_html, returns a string to end the html document. The start_html
function can take more arguments. For instance<br/><br/>
print start_html(-title=>"My Title",<br/>
        -bgcolor=>"red", -text=>"green",<br/>
        -background=>"horrible.jpg");<br/><br/>
would add the background colour, text colour, and background info in the html &lt body &gt bit. </p>

Another common usage of the CGI is to create a CGI object.<br/>
use CGI;					# CGI.pm module<br/>
$cgi = CGI->new;				# construct new CGI object called cgi<br/>
print $cgi->header;				# access cgi's header method<br/>
print $cgi->start_html("Hello World");		# access cgi's  start html method<br/>
<br/> <br/>
So, don't get confused if you see this kind of approach. </p>

<p>
Now, here is an odd piece of code, call it env.pl, what does this do?<br/><br/>
#!/usr/bin/Perl -wT<br/>
use strict;<br/>
use CGI qw(:standard);<br/>
use strict;
print header;<br/>
print start_html("Environment");<br/>

foreach my $key (sort(keys(%ENV))) {<br/>
    print "$key = $ENV{$key}&lt br/ &gt\n";<br/>
}<br/>

print end_html;<br/><br/>


You can see ENV is a hash, usually, you put the data into the hash, and use the keys
function to get the data in the has. However, ENV is a special hash, the Perl interpreter
knows what's in it, it's a list of what all the environment variables are set to. This is pretty useful to have. If we  replace the Hello.cgi with env.cgi, containing the above,  we can see what they all are.</p>




If you run env.pl, other environment variables such as HTTP_COOKIE and HTTP_REFERER do not appear in the list.
For instance, HTTP_COOKIE isn't there because no cookie is being sent to the browser, and  the link HTTP_REFERER
is only there when the page has been accessed through another site.
Lastly the "use strict" line tells that us
that all variables have to be declared as local (using my) or global (using our).
If you leave out my, or our, you will get an error message.



 <br/><br/>


<br/> <a href="#begin"> Back to list of contents </a>
</p>
</blockquote>

<h1 align="center"><a name="forms1"> Processing Forms</a></h1>

<blockquote>
<p>

There are two ways of getting data from a web page, GET and POST. The GET method is the more insecure of the two, as the information is passed as part of the URL, and stored in the environment variable QUERY_STRING. (QUERY_STRING is used as a key in the ENV hash to recover the data sent.) The GET method however, as well as being insecure, has a limit on the size of the data being sent, and GET can be considered obsolete. </p>

<p>
The POST method is now the standard way to send data to the CGI programme. The data is sent after (hence the POST) the url directly to the standard input of the cgi programme.
Now, you could read the standard input and parse the <em>URL encoded</em> string that
contains all the data, but this is definitely <em>not</em> the way to do it.
In URL encoding, spaces are replaced with a plus sign, things like quotes are replaced with %22 and %27. In %XY, X and Y are
  hexadecimal numbers, and %XY represents the ASCII code.
  The contents of the each form field are separated by ampersands.  </p>

  <p>
Here is an example form that uses the POST method.
 <br/><br/>

 &lt !DOCTYPE html<br/>
	PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"<br/>
	 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" &gt <br/>
&lthtml xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" &gt <br/>
&lt head &gt &lt title &gt Form1 &lt/title &gt <br/>
&lt /head &gt body &gt <br/>
&lt  form action="http://localhost/cgi-bin/form.cgi" method="POST"><br/>
Enter text Here: <br/>
&lt input type="text" name="box1text" size=30 &gt &lt br / &gt <br/>
&lt input &gt &lt br / &gt
Enter More text Here: <br/>
&lt input type="text" name="box2text" size=30 &gt &lt br / &gt <br/>
&lt /input &gt <br/>
&lt /form &gt <br/>
&lt /body &gt <br/>
 &lt /html &gt  <br/><br/>

 There are different types of input for forms, here we see type="text" which gives us
 a text box, and type=submit, which gives us a submit form button. The rest is pretty well
 self explanatory. Now, when we hit submit, the form action attribute is set to run the cgi
 script form.cgi.<br/><br/>


#!/usr/bin/Perl -wT<br/>
use strict;<br/>
use CGI qw(:standard);<br/>

#essential in Taint mode<br/>
$ENV{PATH}="/usr/sbin";<br/>

print header;<br/>

print start_html("form");<br/>


my $Length=$ENV{CONTENT_LENGTH};<br/>
print "Content length is $Length &lt br/ &gt\n";<br/>


my @inputarray=param();<br/>

my %FORM;<br/>
foreach my $key ( @inputarray ){<br/>
         $FORM{$key}=param($key);<br/>
         print "$FORM{$key}, name of box containing this is, $key &lt br/ &gt\n";<br/>
                         }<br/>
my $i_input=0;<br/>
print "Begin loop &lt br &gt \n";<br/>
foreach my $key (@inputarray){<br/>
            print "$inputarray[$i_input],  i_input= $i_input &lt br/ &gt\n";<br/>
            $i_input++;<br/>
                                }<br/>


foreach my $key (sort( keys(%ENV) )){<br/>
	print "$key=$ENV{$key} &lt br/ &gt\n";<br/>
     }<br/><br/>


<p>
 Note that the shebang line  has two flags. The w-flag gives warnings, and the -T flag  will run the script in <em>
Taint </em> mode. This means that the data from the input is not to be trusted. Is someone
trying to use the form input to attack you? Has the user at the other end made some silly
typing error which would amount to the same thing? <em>Always </em> use the -T option, it makes your CGI much
more secure than it would be otherwise. Note, that if you now do
"Perl form.pl" to try and debug the cgi script before running it through the browser, you will get a message saying
<br/></br/>
                     Too late for "-T" option
<br/></br/>
Remove the -wT from the fist line, it will now run if you do "Perl -wT form.cgi". When it's
debugged <em>remember to put the -wT back into the first line, or it won't run in taint mode, and you will be vulnerable.</em>. </p>

</p>

<p>
Instead of reading from  &lt STDIN &gt,
we read the data from the form pretty much as we read the data in the ENV hash earlier on.
We could also have had  " my %FORM=Vars()" if we remembered "use CGI qw(:standard Vars);". If you try this out, you will also
find that the URL encoding has been stripped out, and the text that was typed in the boxes appears as is.



<br/> <a href="#begin"> Back to list of contents </a>
</p>
</blockquote>
<h1 align="center"> <a name="mail1" > Sending Mail through CGI </a> </h1>


<blockquote>
<p>
Email can be a big and daunting subject, however we consider only one simple case. This is  where
postfix is running on a single unix like box  which is running Apache. In my case, postfix
was running "out of the box", but some lines have to be added to /etc/postfix/main.cf in order
to actually send mail. These, for me, were <br/><br/>

myhostname=host.local.domain <br/>

mydomain=local.domain<br/>

myorigin=$mydomain<br/>

mydestination=$myhostname localhost.$mydomain $mydomain<br/><br/>

Once that was done,  I could send mail to myself at my ISP at least.
Whether postfix or sendmail 
is running, we still use the sendmail
command, as postfix has a sendmail command as well. In my case it's in /usr/sbin. 
Lets look at a simple Perl script that runs as a CGI script, and reads the text input of a form, and sends the input via email. Below, is formmail.cgi which modifies the above form.cgi.<br/><br/>

#!/usr/bin/Perl<br/>
use strict;<br/>
use CGI qw(:standard);<br/>

#essential in Taint mode<br/>
$ENV{PATH}="/usr/sbin";<br/>

print header;<br/>
print start_html("form_mail");<br/>

my @inputarray=param();<br/>
my %FORM;<br/>
my $i_total=-1;<br/>
foreach my $key ( @inputarray ){<br/>
         $FORM{$key}=param($key);<br/>
         print "$FORM{$key}, name of box containing this is, $key &lt br/ &gt\n";<br/>

         $i_total++;<br/>
                         }<br/>

print "total number of fields=$i_total+1; &lt br &gt\n";<br/>

my $i_input=0;<br/>
my $n_messages=0;<br/>
my @textinput;<br/>
my @boxnames;<br/>
my @messages;<br/>
print "Begin loop &lt br/ &gt\n";<br/>
foreach my $key (@inputarray){<br/>
            print "$inputarray[$i_input],  i_input= $i_input &lt br/&gt\n";<br/>

            push(@boxnames,$key);<br/>
            push(@textinput,$FORM{$inputarray[$i_input]});<br/>

            push(@messages,$key);<br/>
            $n_messages++;<br/>
            push(@messages,$FORM{$inputarray[$i_input]});<br/>
            $n_messages++;<br/>

            print " From FORM Hash, $FORM{$inputarray[$i_input]} &lt br/ &gt \n";<br/>

            print "From array textinput, $textinput[$i_input] &lt br/ &gt\n";<br/>
            print "From array boxnames, $boxnames[$i_input] &lt br/ &gt\n";<br/>
            $i_input++;<br/>
                                }<br/>
 
my $recipient='seagods@uklinux.net';<br/>

print "Trying  to send mail to $recipient &lt br/ &gt \n";<br/>

open (MAIL,"|/usr/sbin/sendmail -t") or dienice("Cannot open pipe to sendmail!:$!\n");<br/>

print "Pipe to Mail now open, print To: &lt br/ &gt\n";<br/>


print MAIL "To: $recipient\n;<br/>
print MAIL "From: $recipient\n";<br/>
print MAIL "Subject: Someone filled in that  stupid form!\n\n";<br/>

#note the \n\n tells sendmail that the header is finished.

my $i=0;<br/>
do{<br/>
   print MAIL "$messages[$i] &lt br/ &gt\n";<br/>
   print MAIL "next line sent=$messages[$i] &lt br/ &gt\n";<br/>
   $i++;<br/>
   }while($i &lt  $n_messages);<br/>


print "Mail has been sent: &lt br/ &gt\n";<br/>

close(MAIL);<br/>
print "Pipe to Mail now closed &lt br/ &gt \n";<br/>


print "end of cgi script &lt br/ &gt\n";<br/>


print end_html;<br/><br/><br/>

sub dienice {<br/>

    my($errmsg)=@_;<br/>
    print "&lt h1 &gt Error &lt /h1 &gt &lt br/ &gt\n";<br/>
    print "&lt p &gt  $errmsg &lt /p &gt &lt br/ &gt\n";<br/>
    print end_html;<br/>
    exit;<br/>
	}<br/><br/>
This time, we strip out all the ENV stuff, read in the form data from the param() function, and declare arrays. One for
the box names, another for the contents of each box, and yet another for the messages to be sent. We have counters to find
out how many of each. The arrays start off as empty arrays, but we use the push function to grow them as the form data comes in.
We don't need to know in advance what the array sizes are, we don't need dynamic memory allocation.
Then we get to the email bit. We have the email address of the recipient, and open a pipe to sendmail, it has the file handle MAIL.
 So, you have to have either sendmail or postfix running on your machine for this to work. (The postfix mail programme also has a
 a sendmail command.) We must print the header information, the last of which must have two newlines, and then the body. It's as
 simple as that. We also have a subroutine dienice which is called if we cannot open a pipe to sendmail. Note that it has
 exit rather than return. The CGI script exits altogether if this subroutine is called.




<br/> <a href="#begin"> Back to list of contents </a>
</p>
</blockquote>

<h1 align="center"><a name="forms2"> More on Forms</a></h1>

<blockquote>
<p>

We shall just finish off with saying a little more on forms. We have looked at a button, and an input field with the text type. There
are of course, other types of input field. The check box, the radio button, and the text area. Consider this daft form. <br/><br/>

 &lt !DOCTYPE html<br/>
	PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"<br/>
	 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" &gt <br/>
&lthtml xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" &gt <br/>
&lt head &gt &lt title &gt Form1 &lt/title &gt <br/>
&lt /head &gt body &gt <br/>

&lt h1 &gt What a Daft Form! &lt /h1 &gt <br/>

&lt form name="Form2" method="POST"  action="http://localhost/cgi-bin/story.cgi" &gt <br/>
First Name:<br/>
&lt input type="text" name="firstname" size=30 &gt <br/>
&lt /input &gt <br/>
Last Name:<br/>
&lt input type="text" name="lastname" size=30 &gt <br/>
&lt /input &gt  <br/><br/>

Are you <br/>
&lt input type="radio" name="stupid" value="A bit thick" &gt A bit thick<br/>
<br/>
&lt input type="radio" name="stupid" value="stupid" &gt Stupid<br/>
<br/>
&lt input type="radio" name="stupid" value="very stupid" &gt very stupid<br/>
<br/>
&lt input type="radio" name="stupid" value="An idiot" checked &gt An Idiot<br/><br/><br/>


Are you <br/>
&lt input type="radio" name="violent" value="a bit aggressive sometimes" checked &gt a bit aggressive sometimes<br/>
<br/>
&lt input type="radio" name="violent" value=" always aggressive" &gt a bit aggressive sometimes<br/>
<br/>
&lt input type="radio" name="violent" value=" extremely aggressive and violent" &gt extremely aggressive and violent&gt <br/>
<br/>
&lt input type="radio" name="violent" value=" a mad axe murderer " &gt a mad axe murderer<br/><br/><br/>


Do you like <br/>
&lt input type="checkbox" name="fluffy bunnies" checked &gt Fluffy Bunnies<br/>

<br/>
&lt input type="checkbox" name="rabid dogs"  &gt Rabid Dogs<br/>

<br/>
&lt input type="checkbox" name="being hit on the head"  &gt Being hit over the head<br/>

<br/><br/>
&lt input type="checkbox" name="sleeping a lot" &gt Sleeping a lot<br/><br/><br/>

Which town do you live in <br/><br/>
&lt select name="town" &gt <br/>
&lt option value="Gotham City" &gt Gotham City<br/>
&lt option value="Salem" &gt Salem<br/>
&lt option value="Kingdom Come" &gt Kingdom Come<br/>
&lt option value="Eternal Hell" selected &gt Eternal Hell selected<br/>
&lt option value="Road Closed"  &gt Road Closed<br/><br/><br/>
&lt /select>
<!-- The selected preselects a particular option in a drop down box, not necessary to preselect any --><br/>

Say a few words about yourself<br/><br/><br/>
&lt textarea rows="10" cols="30" name="textfromarea" &gt <br/>
Enter Here<br/>
&lt /textarea><br/><br/><br/>


&lt input type="submit" &gt <br/>

&lt /form &gt
&lt /body &gt <br/>
 &lt /html &gt  <br/><br/>

 Well, it's fairly obvious what's going on. We have two groups of radio buttons, one is named stupid, the other violent.
 If none is checked, the default is the first in the group, and on clicking the content of stupid changes to the last button clicked.
 Each check box has a different name, if checked it's content is "on". The drop down box has the name town, and the content of
 town contains whichever was chosen, the first in the list unless selected is used as above. The text area has the name textfromarea, and this contains one long string. <p>

 <p>You can easily adapt the formmail.cgi to read this form, also, you can use dienice to validate the input. For instance,
 you can check that at least one of the checkboxes is on, if not call dienice with the message, "you must tell us at least one of
 your likes. Also, you can check if the firstname field is "",  and call dienice with the message "please tell us your first name"
 and so on. If none of the radio buttons is checked, the name of the group of radio buttons isn't seen by params, so you might
  use "checked" as above to ensure that you get at least one value from the named group. This is also true of checkboxes.
   Now of course, there is more to it, but that's the very basics of a form. You might want
 a much tidier looking form, in which case the use of tables should suffice to do the tidying job.

<br/> <a href="#begin"> Back to list of contents </a><br/>
</p>
</blockquote>

<p>
<a href="http://index.html"> Back Home </a>
</p>

</body></html>
