 <!DOCTYPE html PUBLIC "-//W3C//DTD! XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name=Description" content="Getting Started With C++"><br/>
<title>Chris Godsalve, Getting started with C++</title>

<style type="text/css">
@import url(cochise.css);
</style>

</head>
<!-- Background white, links blue (unvisited), navy (visited), red
(active) -->
<body>

<blockquote> Copyright &copy 2004 C. Godsalve, all rights reserved.</blockquote> <br clear="all" />
<blockquote> last update March 2007.</blockquote> <br clear="all" />
<h1 align="center"> <a name="start">Getting Started With C++</a> </h1>



<ul>
<li> <a href="#intro" > Introduction </a></li>
<li> <a href="#vars" > Variables, Pointers, and References </a></li>
<li> <a href="#funcs" > Functions </a></li>
<li> <a href="#control" > Logic and Control </a></li>
<li> <a href="#ArrayMem" > Arrays and Memory </a></li>
<li> <a href="#stringfile" > Strings, Arrays and Files </a></li>
<li> <a href="#object" > Object Oriented Programming: the Class </a></li>
<li> <a href="#construct" > Constructors and Destructors </a></li>
<li> <a href="#overload" > Overload </a></li>
<li> <a href="#inherit" > Inheritance and Polymorphism </a></li>
<li> <a href="#template" > Templates, a Simple Example</a></li>
<li> <a href="#Linked List" > A Linked List and Recursion </a></li>
<li> <a href="#Calling Fortran"> Calling Fortran from C++</a></li>
</ul>


<h1 align="center"> <a name="intro">Introduction </a> </h1>
<blockquote>
<p>
These are a set of notes to myself, I do not guarantee that all here is properly
proof read, or even correct
at all: it is certainly is not a comprehensive C++ course. 
However, these notes might turn out to
 be useful to someone apart from myself, so here they are.
Scripting languages like PHP, Perl, and Java are all very well. 
They run whatever you have written through an interpreter every time the script is called.
Other languages such as C++ and Fortran do not do this. A computer programme
called a  compiler creates the binary code that is
executed. So the stages are, write the programme, run it through the compiler, and run the executable binary file.
 The compilation stage interprets what you have written once only 
and that's that. The binary executable, once right, is never run through any type of interpreter again. This
makes for efficient computing. C++ is a well developed fully object oriented language though it has many procedural elements.  It is so prevalent, that it's a "must learn" language, though some people might tell you it's
difficult, it's not that bad really.
<p>
<p>
Now, to get started, you need a compiler. You can download an excellent compiler 
called GCC (the Gnu Compiler Collection, which includes the g++ C++ compiler).
 This is the GNU software
compiler, and it's  free. If you're running linux, you may already have it, or 
it will be on the installation disks. 
Installing gcc not only gives you C and C++, it
 gives you Fortran 77. You can call C or C++ from Fortran and Fortran from C or C++. 
Whatever your opeating system, you can also download the latest GCC from
<a href="http://gcc.gnu.org" > for free </a>. 
</p>
<p>
Now it is 
 time for the ubiquitous Hello world, you're first C++ programme.<br/><br/>
 #include &lt iostream &gt <br/>
int main(){<br/>
&nbsp  &nbsp  std::cout &lt &lt  "Hello World, This is C++" &lt &lt std::endl;<br/>
&nbsp  &nbsp return 0;<br/>
       }<br/>
So what's all this about? First there is a statement #include &lt iostream &gt . Both C and C++ include chunks of
code which are in an include directory. This one for instance includes a chunk of code that tells it what the "cin" and "cout" functions are. Next, we have the int main() followed 
by an opening brace, then "stuff", then a closing brace. The braces define a code block.
Every C/C++ function must have a main function, in this case we tell it
that it returns something with the int (integer) data type. Remember, something else could be calling  our
programme, and it might test whether its return value is zero (for success) or another number, for an error code.
The main function might take some arguments, these go in the parentheses. In 
this case, main takes no arguments, so main is 
followed by (), the parentheses are left empty but they must be there. 
The cout function (pronounced See-Out)
writes to 
the screen. It's given a string of characters in quotes via the &lt &lt which you might visualise
as feeding the cout function, further strings could be fed into cout, in this case we feed it with a std:endl
(end line). Any command is finished off with a semicolon, and we finish the code with a return zero.
It is important to note that C and C++ are <em> case sensitive </em>. So if you call
something "Fred", neither fred nor FRED will be recognised as Fred. This goes for commands
as well as data.

So
now it's time to compile. For intel, this is done with 
"icc -static -o Hello Hello.cpp" at the command line,
for g++ it's "g++ -o Hello Hello.cpp", it will work without the static bits. 
From now on, in these pages,
we   shall assume
 that g++ is being used. </p>

<p>
All this
is for the  newer g++ compilers. In others, you might need iostream.h instead of iostream, and you might not need the std::
in front of the cout (which tells the intel compiler that its one of the std [for standard] methods). Puting "using namespace std" before the main() statement means that you will no longer need the "std::" bit before using things like cout.

The -o Hello  in the compilation command tells the compiler that it  should create 
an "object file" called Hello.o, and  that the executable will stored
in a file named Hello. 
If the -o Hello 
option is not used, the executable will be named  a.out and there will be no object file.
(An object file is an "in between" stage of compilation that can be linked to library
programmes and other object files to create one big executable. It isn't necessary to
create one for the Hello program.)
Of course,  Hello.cpp is just the file containing the 
source code as written above, and there it is.

 <h1> <a name="vars" > Variables, Pointers, and References </a></h1>

 First off, C++ is a strongly typed language. Anything in a programme has to
 be given a type. You cannot just
 type in  x=5 or letter='a', or y=2.43635. You have to tell the compiler what
 "type" x actually is by "declaring" it. The compiler
 knows how much memory the type takes, and the declaration will assign it a place
 in memory, and the type tells it exactly how to interpret all those ones
 and zeros stored in that chunk of memory. Some different types are
 "int", "unsigned int", "short int", "char", "float" and "double". These in turn are
 integers, 4 bytes for an signed or unsigned integer, 2 bytes for a short 
 integer. A character (char) can be a letter, but it can also be used as
 a one byte integer. The types float and double are decimal numbers of four 
 and eight bytes
 respectively. Lets try it out with the following code. (Here \n means "new line" and 
 is used instead of the std::endl above)<br/><br/>

#include &lt iostream &gt <br/>
int main(){<br/>
&nbsp  &nbsp int i;<br/>
&nbsp  &nbsp short int j;<br/>
&nbsp  &nbsp unsigned int k;<br/>
&nbsp  &nbsp unsigned short int l;<br/>
&nbsp  &nbsp char A='a',B=99;<br/>

&nbsp  &nbsp float x;<br/>
&nbsp  &nbsp double y;<br/>
<br/>

&nbsp  &nbsp i=3000000000;<br/>
&nbsp  &nbsp std::cout &lt &lt "integer i is " &lt &lt i &lt &lt "\n";<br/>

&nbsp  &nbsp i=2000000000;<br/>
&nbsp  &nbsp std::cout &lt &lt  "integer i is " &lt &lt i &lt &lt "\n";<br/>

&nbsp  &nbsp k=4000000000;<br/>
&nbsp  &nbsp std::cout &lt &lt  "integer k is " &lt &lt k &lt &lt "\n";<br/>

&nbsp  &nbsp j=200000000;<br/>
&nbsp  &nbsp std::cout &lt &lt  "integer j is " &lt &lt j &lt &lt"\n";

&nbsp  &nbsp j=32767;<br/>
&nbsp  &nbsp std::cout &lt &lt  "integer j is " &lt &lt j &lt &lt "\n";

&nbsp  &nbsp j=32768;<br/>
&nbsp  &nbsp std::cout &lt &lt  "integer j is " &lt &lt j &lt &lt "\n";<br/>


&nbsp  &nbsp l=65535;<br/>
&nbsp  &nbsp std::cout &lt &lt  "integer l is " &lt &lt l &lt &lt "\n";<br/>

&nbsp  &nbsp x=1.0e-40;<br/>
&nbsp  &nbsp std::cout &lt &lt  "number x is " &lt &lt x &lt &lt "\n";<br/>

&nbsp  &nbsp x=3.4e38;<br/>
&nbsp  &nbsp std::cout &lt &lt  "number x is " &lt &lt x &lt &lt "\n";<br/>

&nbsp  &nbsp y=1.5e-320;<br/>
&nbsp  &nbsp std::cout &lt &lt  "number y is " &lt &lt y &lt &lt "\n";<br/>

&nbsp  &nbsp y=1.74e308;<br/>
&nbsp  &nbsp std::cout &lt &lt  "number y is " &lt &lt y &lt &lt "\n";<br/>

&nbsp  &nbsp A='a';<br/>
&nbsp  &nbsp std::cout &lt &lt  "char A is " &lt &lt A &lt &lt "\n";<br/>

&nbsp  &nbsp A=A+1;<br/>
&nbsp  &nbsp std::cout &lt &lt "char A is " &lt &lt A &lt &lt "\n";<br/>

&nbsp  &nbsp A++;<br/>
&nbsp  &nbsp std::cout &lt &lt "char A is " &lt &lt A &lt &lt "\n";<br/>

&nbsp  &nbsp i=A;<br/>
&nbsp  &nbsp std::cout &lt &lt  "int i is " &lt &lt i &lt &lt "\n";<br/>

&nbsp  &nbsp A=2*A-10;<br/>
&nbsp  &nbsp std::cout &lt &lt  "char A is "&lt &lt A &lt &lt "\n";<br/>

&nbsp  &nbsp std::cout &lt &lt  "char B is " &lt &lt B &lt &lt "\n";<br/>
&nbsp  &nbsp std::cout &lt &lt  "char B is " &lt &lt (int)B &lt &lt "\n";<br/>

&nbsp  &nbsp int *ipoint;<br/>

&nbsp  &nbsp i=5;<br/>
&nbsp  &nbsp ipoint=&i;<br/>
&nbsp  &nbsp std::cout &lt &lt  "The integer i has an address " &lt &lt ipoint &lt &lt "\n";<br/>
&nbsp  &nbsp std::cout &lt &lt  "The address contains" &lt &lt *ipoint &lt &lt "\n";<br/>

}<br/><br/>
</p>
<p>
We now explain what is going on in the above code. (Results may be compiler and machine
dependent, so play around if things turn out differently.)
The code itself  is simple enough, but  it demonstrates quite a lot. First 
look at the integer i. It is declared (int i) 
but not given a value or <em>initialised </em>. In some languages, an integer or float
would automatically contain
0, but in C/C++, it can contain any rubbish before it is given a value. Beware of the fact that, until initialised, data can be anything, and that uninitialised 
integers, characters, floats and so on, can cause problems. This integer
is inititialised as 3000000000, and then printed. What appears on printing 
is -1294967296. Why? An integer is 4 bytes long, that is 32 bits, so in binary
we can have from zero to 2<sup>32</sup>-1 if there is the integer is unsigned, but about
plus or minus about half of that for an int (which is signed). In a signed integer
the very first bit detemines the sign; zero for positive, 1 for negative.
So, from 0 to 217483645, everything is fine, but when we add one, the sign bit
changes from 0 to 1. We are at minus
217483646. It has wrapped around to the largest (in magnitude) negative number
it can store in an int. That's how the bits are stored. Take a
one byte integer, the very first
bit determines the sign, so when we add 1 to 01111111 (127), we get 10000000, the 
sign byte has changed to negative
and  the number is interpreted as -128. Then 10000001 is -127, and so on. (This
seems odd, but is more efficient in terms of computer architecture.)
Once we get to 11111111 (-1) and add one, we get 00000000 instead of
100000000, there is no room in the byte for the 1, so we get zero. It just 
keeps wrapping round as we add more
ones.
</p>
<p>
Since k is unsigned, it has no problem with 4 billion at all.
The story is similar for j, this is a short
integer, so it has only two bytes. First j is initialised as a number that 
two bytes just cannot hold, j is wrapped around many times, and then 
prints out -15872, which is rubbish. Then j is given 32767, the largest
that a short int can be, we add 1 to j, and it wraps around to -32768. Then 
the unsigned short int l is given it's largest possible value, try adding one more to l. it will wrap back round to zero.
</p>
<p>
The  next numbers are x and y which are float and double respectively.
In this notation the number is written in scientific notation, 
so 1.3 &times 10 <sup> 10</sup> is written 1.3e-10. Here 10 is the exponent, and
the 1.3 is the mantissa. A float has 8 bits for the exponent, and 23 bits 
for the mantissa. So, a float's
exponent can take values from -128 to 127, and 2<sup>127</sup> is
about 10</sup>38. If the (absolute) value of x is too small,
 it can lose precision. Some decimals can be chopped off. If x is assigned
 a value for x that is small enough  
the compiler will think it's actually zero.
Then x is set to a large number which it can handle. Try making it larger. It doesn't need to get that
much larger and you get inf for infinity. Its not infinity, it's just the compiler's way of flagging that
the number is too big for the number of bytes. As well as inf, there is N&N. This happens when you get
things like 0*inf (* is times / is divide) 0/0, inf/inf. The N&N is read as "not a number", and flags up
that the compiler can't do anything with what it's given. The double type is similar, the first bit is the sign, the next 11 bits are the exponent, the rest is the mantissa. For the exponent we have numbers as large as 2 <sup> 1028 </sup> which is about 10 <sup> 308 </sup>, which gives a rough handle on the order of magnitude
range.
</p>
<p>
As stated, it is important to watch out for  precision, for instance, if "eps"
is a small number, then the result 1.0+eps may lose accuracy, in fact, one of the
"machine constants" should be the smallest value of eps such that 1.0+eps doesn't
give a result of 1.0. Usually when a programme runs, you may get warnings such as inexact, underflow, and overflow. This
may (or may not) tell you that your calculation has gone wrong. It usually depends on the problem. Look up IEEE floating point precision for more detail.
</p>
<p>
Next we come to the characters. These are one byte only. The numbers 0-9 have ASCII codes 30 to 39,
A to Z are 65 to 90, and a-z are 97 to 122. There are 127 characters in the ASCII set, some of which won't appear when written to the standard output (usually the screen). Note that in the declarations, two characters are declared and
initialised at the same time. Another point is that we can find what the value of the character is
by writing out (int)A or (int)B. This type of data conversion is called casting. Note that we get the same
wrap around if A or B are higher than 127, in which case the characters printed are not in the ASCII standard range.
Characters are often used to read binary data images one byte at a time.
</p>
<p>
Note that we have things like A=A+1 and A=A*2-10. The equals sign does 
not mean "is equal to".  is an <em>assignment</em>
operator. The value of A is located in memory somewhere.
Whatever A's value is, it is stored in ones and zeroes at A's address. 
The value of A  is taken from that address, 1 is added to it, and the result
overwrites section of memory where A was stored.  In the second case 
the value of A is read, multiplied by two and
the result  has 10 subtracted. Once this is done, the result goes into A's memory slot.
 (The multiplication operator has precedence over the minus operator.)
</p>
<p>
The reason that all this can be done is that everything that is
named or declared, i,j,k,l,x,y,A, and B, automaticallt has an address. The
address is a code (in hexadecimal) where the actual ones and zeros are. The type
tells the compiler how much memory is at that address. We can store the memory address of 
anything in 
a <em>pointer</em>. (Pointers are an important part of C and C++.)
A pointer to an integer is declared with int *ipoint.
Then ipoint is a variable in itself, and it in turn has its own address.
The reference operator & is used to find the
address of i in ipoint=&i.  We find what's at the address
by <em>dereferencing </em> the pointer.
In the above code, this is done by writing out *ipoint. 
So, ipoint contains the  hexadecimal address of i, and *ipoint 
is what's contained in that address. So, in these terms,  when we put A=A+1, the
computer goes to
 the address of A, finds what's there
and replaces it with what's on the right hand side  of the assignment operator.
</p>
<p>
One last thing should be mentioned here, and that is about  division and integers.
If I put i=1/2 the result will be i=0.
The values of 2/2 and 3/2 will both be one. The result is always rounded down. 
the integer i cannot contain
0.5 or 1.5, any fractional part is discarded leaving 0 and 1, and it is always rounded down.

<br/>
 <a href="#start" > Back to list of contents</a>
</p>
</blockquote>

<h1 align="center"> <a name="funcs">Functions </a> </h1>
<blockquote>
</p>
Functions are a means of organising code into blocks. For instance, if you have a programme where
a block of code is repeated all over the place, it should be tidied away in a function. Also, if
the main code has a series of tasks, it's more readable if each task is put in a function.
We shall start off, as most C++ tutorials do, with a swap function that doesn't work. Why start
with that? Because it outlines how functions are written, while illustrating a trap which might easily
be fallen into. Here is the code.
</p>
<p>
<br/><br/>

#include &lt iostream &gt <br/>
using namespace std;<br/>

int swap(int , int );<br/>
int main(){<br/>

&nbsp  &nbsp int i=5, j=6;<br/>
&nbsp  &nbsp cout &lt &lt  "i=" &lt &lt  i &lt &lt  " and j=" &lt &lt j &lt &lt  endl;<br/>

&nbsp  &nbsp int k=swap (i,j);<br/>
&nbsp  &nbsp cout &lt &lt  "i=" &lt &lt  i &lt &lt  " and j=" &lt &lt j &lt &lt  endl;<br/>
&nbsp  &nbsp return 0;
}<br/>
int swap(int i, int j)<br/>
{<br/>
&nbsp  &nbsp int temp=i;<br/>
&nbsp  &nbsp i=j;<br/>
&nbsp  &nbsp j=temp;<br/>
&nbsp  &nbsp cout &lt &lt  "i=" &lt &lt  i &lt &lt  " and j=" &lt &lt j &lt &lt  endl;<br/>
&nbsp  &nbsp return 0;<br/>
}<br/>


<br/><br/>
</p>

<p>
First off, having got fed up with writing std:: we tell the compiler we are using the std namespace.
Maybe I shall say more on that some other time. The first important bit is the function <em>prototype </em>.
We tell the compiler that there is a function called swap, that it is to return an integer (that's the
int swap bit) and its to take two arguments, the (int, int) bit. We could have put (int i, int j)
or some names to remind us of something, but the compiler ignores this. We can put something
that makes the code a bit easier to follow, or nothing at
all. So, int swap(int,int) is the prototype. A function called func need take no arguments at all. Then it would be func(). Return values are often used as codes for what happened in the function, return 0;
is often use to indicate that there was no problem. The main function must have an int value by convention,
because the main code might be called by a script which wants an error code.
The function prototype could have gone into the main() function.
</p>
Next we declare two integers and give them values. We call the swap function at int k=swap(i,j).
This passes control to the function swap. The integers i and j are declared at int swap(int i, int j).
Then we swap the integers. the cout line will show they have been swapped. Now this function
returns an integer, but the integer it returns is of no use. In this case we could have declared
that the function by void swap(int,int) and called it just by "swap(i,j);" in the main programme.
Then it writes out the numbers to the screen, but they are not swapped!
</p>
<p>
This is because the variables i and j in the function are <em> local variables</em>. Calling swap(i,j)
passes <em> copies </em> of i and j to the swap function. These copies are swapped, and then the go
<em> out of scope </em> when the function is finished and control is passed to the main loop.
The variables local to swap(i,j) have vanished in a puff of smoke. You can also have <em>global
variables</em>. These must be declared outside any loop, for instance<br/><br/>
extern int  K;
<br/><br/>
declares the integer K to be external or global. It cannot be initialised here. In the main
function, or anywhere, you must declare it again.
<br/><br/>
int K=5;
<br/><br/>

</p>
<p>
There are two ways we may write a swap function that actually swaps. We can use pointers, or pass by reference.<br/><br/>
#include &lt iostream &gt <br/>
using namespace std;<br/>
void  swap(int *, int *);<br/>
&nbsp  &nbsp int  main(){<br/>
&nbsp  &nbsp int i, j;<br/>
&nbsp  &nbsp i=5;  j=6;<br/>
&nbsp  &nbsp swap (&i,&j);<br/>
&nbsp  &nbsp return 0;
}<br/>

void  swap(int *i, int *j)<br/>
{<br/>
&nbsp  &nbsp int temp=*i;<br/>
&nbsp  &nbsp *i=*j;<br/>
&nbsp  &nbsp *j=temp;<br/>
}<br/><br/><br/>

#include &lt iostream &gt <br/>
using namespace std;<br/>

int swap(int &, int &);<br/>
int main(){<br/>

&nbsp  &nbsp int i=5, j=6;<br/>


&nbsp  &nbsp int k=swap (i,j);<br/>
&nbsp  &nbsp return 0;
}<br/>
int swap(int &i, int &j)<br/>
{<br/>
&nbsp  &nbsp int temp=i;<br/>
&nbsp  &nbsp i=j;<br/>
&nbsp  &nbsp j=temp;<br/>
&nbsp  &nbsp return 0;<br/>
}<br/>
In the first listing, swap now takes two pointers. We call it by passing copies of the
addresses of i and j, but now *i=*j actually puts j's contents into i's actual address.
The values of i and j are swapped.
</p>
</p>
The second listing is much nicer. Here we prototype the function to take two references
to integers. Now we call it by swap(i,j), and within the swap routine there are no
pointers lurking about. So, the person who is adding swap to the main routine need
not know anything about pointers and addresses, or the person writing the swap function.
As long as it's prototyped correctly, things look a lot simpler than passing addresses
and dereferencing them as in the pointers method.
</p>
<p>
Later we shall see that the objects passed to a function can be a lot more complicated
than an int or a float, and they can also be quite large as far as data
is concerned. This means that passing by copy is a bad idea, not only for that reason,
 but because when these objects are passed, a function called a copy constructor
 has to be called.


<br/>
 <a href="#start" > Back to list of contents</a>
</p>
</blockquote>


<h1 align="center"> <a name="control" > Logic and Control </a></h1>
<blockquote>
<p>

The C programming language has features for controlling what a programme does. (Everything
apart from cout and iostream  here is just C, and C++ contains C. I shall arrive at C++ later)
There is the if statement, if so and so is true, do this, do something else otherwise. This looks like<br/><br/>
if(expression)<br/>{<br/>
 &nbsp  &nbsp    // do this<br/>
    }<br/><br/>
    or <br/><br/>
if(expression)<br/>{<br/>
 &nbsp  &nbsp   // do this<br/>
   }<br/>
   else<br/>
   {<br/>
&nbsp  &nbsp    //do the other }
   <br/><br/>
   or<br/><br/>
if(expression)<br/>{<br/>
 &nbsp  &nbsp  //do this<br/>
  }<br/>
  else if(){<br/>
    &nbsp  &nbsp    //further tests<br/>
     &nbsp  &nbsp   }<br/><br/>
By expression, I mean a logical expression which may be true or false. You can declare a Boolean variable
like this. <br/><br/>

bool toohigh;<br/>
bool toolow=true;<br/>
if(i>1000)<br/>
 &nbsp  &nbsp     toohigh=true;<br/><br/>
Here > means greater than. Note the if statement lacks braces, you can leave them out if there
is only one statement to be executed if the expression is true. The expression i>100 is either
true or false, so that's a Boolean expression also. The symbol &lt means less than. Then there
is less than or equal to, &lt =, and similarly greater than or equal to, &gt =.
</p>
<p>
A really important point is that = does not mean equal to as far as logic is concerned, toolow=true
<em> assigns </em> the value true to toohigh, if(i=5) assigns the value 
of 5 to i. So = is the <em> assignment operator </em>. The equality operator is "==". If we want
to test if i is 5 or not 5, we use 
if(i==5). It is often difficult to spot if someones accidentally
left off the extra equals, and this will be the source of a mysterious bug. Why the hell does
the programme  suddenly "think" i=5,  it is  because of the if(i=5) mistake.
</p>
<p>
Now there are logical operators, there is && for AND, || for OR, ! for NOT, but no XOR.
So we can have if(johnismarried && johnistall). On top of these there bitwise operators.
These are !, & and |, for NOT, AND, and OR, here there is an ^ for XOR.
</p>
<p>
Sometimes if statements can be rather awkward, but in many of these awkward cases the switch statement can be used
instead. It looks like <br/> <br/>

i=myfunction(j,k,l);<br/>
switch(i){<br/>
&nbsp  &nbsp  	case 0:<br/>
&nbsp  &nbsp  &nbsp  &nbsp  	   //what do if i=0;<br/>
&nbsp  &nbsp  &nbsp  &nbsp  	   break;<br/>
&nbsp  &nbsp  	   case 1:<br/>
&nbsp  &nbsp  &nbsp  &nbsp  	   //what to do if i=1;<br/>
&nbsp  &nbsp  &nbsp  &nbsp  	   break;<br/>
&nbsp  &nbsp 	   case 2:<br/>
&nbsp  &nbsp  &nbsp  &nbsp  	   //what to do if i=2;<br/>
&nbsp  &nbsp  &nbsp  &nbsp  	   break;<br/>
&nbsp  &nbsp  	   default:<br/>
&nbsp  &nbsp  &nbsp  &nbsp  	   //what to do if none of the above<br/>
&nbsp  &nbsp  &nbsp  &nbsp  	   break;<br/>
&nbsp  &nbsp  	   }<br/><br/>
</p>
<p>
Often, we need to do something over and over while some variable changes, and there are
control loops for these situations. Before going on to these, there are a few more
operators to know about. There are ++ and --, the increment and decrement operators.
You could write i=i+1, or i++, both increment i by one. Note that you can also have ++i.
Often the result is the same, but watch out. Suppose you have if(i++==N) somewhere,
You want to know if i is increased by one it has reached a critical value, and if you add
one more to i something bad will happen. The postfixed ++ uses i after it has been
incremented so all is fine, but if(++i==N) has a prefix operator, it uses i before incrementing it, and the
test won't do the job.

</p>
<p>
Loops are very useful, and there are variations of them. I shall describe them briefly.
There is the for loop. <br/> <br/>
</p>
<p>
<br/><br/>
for( int i=0; i &lt MAX; i++)
{ <br/>
&nbsp  &nbsp  // do stuff <br/>
} <br/> <br/>
Here i is a counter, first it must be initialised, then comes a logical expression, then an increment,
all separated by semicolons within the parentheses. As long as the logical expression remains true
it will keep on repeating whatever do stuff is. You can make it an infinite loop using for(;;).
These are often useful, within the loop, something can be tested, and a break; statement
can be used to jump out of any loop. Also, there is a continue statement that goes back
to the top of the loop without executing what is in the code block below it. Lastly, there
is the infamous goto statement. This looks like goto thatplace; and somewhere else in the code
you have thatplace:  cout &lt &lt "got to that place\n";. It was infamous for being badly used,
 making code completely unintelligible. It can be used, but in general it just is not necessary,
 so the general advice is to steer clear of using  goto statements.
</p>
<p>

Then there are while loops, do while loops.
They are pretty obvious.</br></br>

while(expression){</br>
  &nbsp  &nbsp  //do stuff</br>
  }</br>
</br>
and</br>
</br>
do{</br>
 &nbsp  &nbsp  //do stuff</br>
}while(expression)</br></br>
You can make this an infinite loop with while(true) or while(1). (In C and C++ 1 is true
and anything but 1 is false.) The difference between the two whiles is that the do while
executes the code block in braces (anything in braces is a code block) then checks the expression
rather than the other way round.
With all the logical features, looping features, and the  use of function calls, you can
get the code to behave how you want.

 Before leaving the section, we make a couple of points. any of the code blocks
in an if statement or a loop can have if statements and loops within them. That
is to say, you can nest if statements and loops as much as you want. Also,
remember that you can declare variables anywhere you want.  If you declare
a variable in a code block (anything between braces {}, that variable
is a local variable within that code block. This can be useful, or a source
of errors that are difficult to find. 





<br/>
 <a href="#start" > Back to list of contents</a>
</p>
</blockquote>

<h1 align="center"> <a name ="ArrayMem" > Arrays and Memory </a></h1>
<blockquote>
<p>

An array of integers is just like
a list. Brackets [] are used to indicate an item's place in the list. So, in C/C++
 "int A[10]" declares an array of 10 integers, A[0] is the first one, and A[9]
the tenth. So we have 10 memory slots for integers in one go. The name A is in fact
the address of the Array A. So, *A is the same as A[0]. Not only that, but the address of
A[1] is A+1, so *(A+1) is in fact A[1] and so on. Array numbers starting at zero will bug
you if you are a FORTRAN programmer.
</p>
<p>

You can have arrays of arrays. So
int B[10][10] declares space for 100 integers in a 10 by 10 matrix.
An element in the matrix is B[row number] [column number].  The two
pairs of brackets may seem cumbersome, but the do make it clear that
it is B is an array of arrays.

Now, B contains  
an address,
but what is stored in the address of B? It contains the address of an 
array consisting of the first row.
In other words, B is a pointer to a pointer. 
 </p>
 <p> 
 Suppose B is the address of a two by two array declared by int B[2][2]. 
 Since B is the address of
 the first row, *(*B) or **B is B[0][0]. The result
 of **(B+1) </em> or *(*(B+1)) </em> is B[1][0], i.e. B+1 holds the 
address of the second row.

In a two by two matrix, *(*(B+0)+0) is B[0][0],  *(*(B+0)+1) is B[0][1], 
*(*(B+1)+0) is B[1][0], and *(*(B+1)+1) is B[1][1].


</p>
<p>
Now, instead of declaring B to be a matrix, we could have just declared
the pointer with int *B; but now
this is just a memory address. If it's to be a matrix, it needs to be  pointing to a larger area of memory than
just that space for an integer. Who knows we will be overwriting if we put *( (*B+1)+1)=5, say. Before
filling in the matrix, we have to tell the compiler what amount of memory B needs. This is done by
by using memory allocation functions, either malloc or calloc will do. <br/><br/>

int *B;<br/>
int *C;<br/>

B=(int*)malloc(2*2*sizeof(int));<br/>
  if(B==NULL){ cout &lt &lt "FAILED\n";  exit(0); }<br/>
C=(int*)calloc(2*2, sizeof(int);<br/>
 if(C==NULL){ cout &lt &lt "FAILED\n";  exit(0); }<br/><br/>

Notice the (int*) before the malloc and calloc. This is an example of <em>casting</em> where the
compiler is told to convert what a function returns to whatever type is in the brackets. For instance,
if myfunc() returns an integer, x=(float)myfunc() will convert the return value of myfunc to a float.
</p>
<p>
All this was done automatically
with int B[2][2]; so why have this method of declaring an array. There are different reasons.
One is that the array size may not be known before the programme runs. The array size might
depend on the input data for instance. Another is that we might be pushing at our memory limits.
Note how we checked for malloc an calloc returning a NULL pointer. If they do return NULL, you have
run out of memory.
</p>
</p>
In this case we might want to free up the memory for any large arrays or objects
as soon as they have done their job. To do this, we use the free function. The
command free(B); will free up that memory so that new data can now occupy that space.
However all this data is on the programme stack.
</p>
<p>
 There is another area of memory called the heap, on the heap, this
 consists of nearly all the virtual memory on the machine.
 To declare an object on the heap you use the new operator.<br/><br/>

 int* B=new int;<br/><br/>
 Now memory can be allocated to B. Notice new int returns a pointer to an integer, not an integer.
 To free the memory later on just use delete B;. Note, delete (or free) just frees the memory for other
 objects to be declared on the heap, B is still pointing
 to that memory address. As a safety measure, set B to NULL. (At this point, some say its a bad habit
 to use NULL, its better to use 0 instead.)
<p>
</p>
Suppose you have already allocated the memory, then as the programme is running, you find you need
more memory for an existing array. Conversely, you might have a huge array, but now you only need
something a tenth of the size. Here you use realloc. Its usage is the same as calloc. The number
you give it is the new array size, not what is to be added to or subtracted from the  original
array. If you do B=realloc(0,sizeof(int)) then that's the same as delete


<br/>
 <a href="#start" > Back to list of contents</a>
</p>
</blockquote>



<h1 align="center"> <a name ="stringfile" > Strings, Arrays, and Files </a></h1>
<blockquote>
<p>
Whatever you are doing, you won't get far without reading and writing data from and to files.
Also, you won't get far without using strings and characters .
There are a lot of things you can do with text in C and C++, and it's very useful.
For instance, using characters, you can read in a binary file one byte at a time.
First of all, there are the putchar and getchar functions. The getchar function
returns an integer which represents the ascii code of the character, it will just wait for a 
character from the standard input. So</br></br>

int i=getchar();</br>
putchar(i);</br></br>
will sit there until you type in the letter r say, and then echo r to the standard output.
We might also use getchar to  return a character variable mychar, and use mychar=getchar(); and 
putchar(mychar);. Also, there are the getch() and ungetch() functions. The difference here
is that while getch() behaves like getchar, it has an inverse, so you can put a character back, say
if it is not alphanumeric.
It doesn't look useful yet? It will do.  </p>

<p>
Now things like "Hello\n" are actually character arrays. Here we could have char* Greeting[7],
with Greetint[0]='H', ..., Greeting[5]='\n'. What about the last one? That is Greeting[6]='\0'
which is the string terminating character. If you #include &lt string.h> you can use functions
such as strcat,strcmp,strcpy,strlen, and strsave. These concatenate strings, copy strings
into character arrays, compare strings, return the length of a string, and makes a new copy
of a string at a different memory location. The last one is not standard ANSI C though.
We shall have a brief look at these. <br/> <br/>

char *One; <br/>
const char* Two="Bee\n"; <br/>

One=(char*)malloc(50*sizeof(char)); <br/>
strcpy(One, " Busy"); <br/>

strcat(One, Two); <br/>

int ilength=strlen(One); <br/> <br/>

Here we have used the const keyword for the string held in Two, this makes it "read only", it cannot be
changed. It must be initialised in the same line as it is declared in. One points to a place in memory
that is big enough to hold a character, and is to be interpreted as a character. There is garbage
in that memory area until it is initialised.  We cannot use strcpy yet, as we have to allocate the
memory for a string first. The strcpy function copies a constant string into the character array One.
Then strcat is used, again the second argument is a pointer to a constant string. If you're trying
to use these functions it crashes with a segmentation fault, (usually) you haven't declared enough
memory for the resulting string.

</p>

<p>
Now, as well as reading and writing from and to the standard input, we can do the
same with a string or a file. A file is accessed using a file pointer. The usage is

<br/> <br/>

FILE *fp;<br/>

fp=fopen("filename","w");<br/>

fprintf(fp,"%d %d \n", i, j);<br/>

fclose(fp);<br/>

<br/> <br/>

Here, we have opened a file to write to. The file is opened by declaring
 *fp to be a file pointer using the FILE data type. So, we could declare
 FILE *myfirstfile for instance. The "w" bit tells the compiler that the file
is to be written to. If the file already exists, and if we want to append to the
file, a is used instead of w. (If we use w in this instance the file will be overwritten.) Also r is used 
when we want to read from a file. The functions  getchar(fp) and putchar(i,fp) are the same as getchar and putchar, except
now they are given a file pointer as an argument. 
There same goes for  getch and ungetch functions. The function printf is explained below.
The last character in any file will be the file terminator EOF.
So while(mychar=getchar() != EOF) gets characters until the end of file is reached.

<p>
</p>
This is by no means a detailed account of the subjects, I will finish off with some
other input output stuff, which needs a #include &lt stdio.h &.gt to include these functions
 These are printf sprintf, fprintf,
 and scanf, sscanf and fscanf. The functions print to or read from the standard input,
 strings, or files respectively. First, look at printf <br/> <br/>

 printf(" I am %4d years old and weigh %6.3f kilos\n", age, weight); <br/> <br/>

 Printf takes a string, but there are bits that start with a percent sign and finish with
 a letter. These are formatted numbers. The letters used can be d for denary integer (base 10),
  f for float, o for octal, x for hexadecimal, c for character, and s for string. 
For outputting floating point numbers in scientific notation we can use %e or %E depending on whether
you want a upper or lower case e in the output. Also p allows you to print pointer addresses.
  The letters d and f
  can be preceded by a letter l to indicate long integers or double precision, and the letter h
  is for short integer. To print percent, you need %%.
  You can have any number of these, as long as they are matched correctly in the list after the string.
  If there are no variables such as these to be printed, there is no list, so printf("Hello\n") is fine.
</p>
<p>
Now, the function corresponding to printf that reads from the standard input is scanf. <br/> <br/>
scanf( "%2d %f %s", &age, &weight, name);<br/><br/>
Note that the age and weight must be addresses, of course in the case of the string, it's an array, so name
is the address as above. Then, to read and write in the case of strings, we have sscanf and sprintf. The
only differences is that the first argument is the name of the string, so sprintf(mystring, "%d", i)
will print the integer i to the string. In the case of files, the string would be replaced with the file
pointer.
<br/>
 <a href="#start" > Back to list of contents</a>
</p>
</blockquote>

<h1 align="center"> <a name="object" > Object Oriented Programming: the Class </a></h1>
<blockquote>
<p>
So far, we have not really touched on C++, we have focused on C, which is contained by C++, this allows us
to do all the procedural stuff. Now we come to classes of objects. For instance we may have a class of customers,
a class of matrices, a class of children, or a class of cats. We shall have a class of cats as an example. Once
we have defined a class, tiddles, or fangs, might be an instance of that class.
</p>
<p>
Let's look at an extremely simple example.<br/><br/>
#include &lt iostream &gt <br/>
using namespace std;<br/>
class Cat{<br/>

 &nbsp  &nbsp    public:<br/>
 &nbsp  &nbsp  &nbsp  &nbsp      int age;<br/>
 &nbsp  &nbsp  &nbsp  &nbsp      float weight;<br/>
};<br/>
int main(){<br/>

&nbsp  &nbsp  Cat cat1;<br/>

&nbsp  &nbsp  cat1.age=5;<br/>
&nbsp  &nbsp  cat1.weight=1.3;<br/>

&nbsp  &nbsp  cout &lt &lt  "cats age  is "  &lt &lt  cat1.age  &lt &lt  " years old and it weighs "  &lt &lt  cat1.weight  &lt &lt  "  Kilos"  &lt &lt  endl;<br/>
}<br/>
If you're a C programmer, you will say, "Why that's almost identical to a struct!". The root of classes of objects in C++ does
indeed look like it has built on the C struct, which was used to bundle data of different types into a "structure".
It would have been<br/><br/>
struct cat{<br/>
  &nbsp  &nbsp    int age;<br/>
 &nbsp  &nbsp     float weight;<br/>
    };<br/><br/>
then we would have declared it with "struct Cat cat1;" The usage of the member operator "." is the same as in a struct.
So what's new. First, a class can have a set of functions, usually described as <em> methods </em>, as class members.
Both the data and the methods can be  public or private. If it's public, any instance of the class can access the
data, as we saw with cat1.age. If age were private, cat1 could not have accessed the data. Usually data like this are private.
The methods are usually public. Any data are accessed through these  methods, so we would have accessor functions to set
the cats age or get the cats age. Note that if we had a pointer to a cat, Cat *ptrCat, the syntax for accessing member
functions is ptrCat->whatever(); Also, in any member function, there is a special pointer called this. If you
are in a debugger in the function whatever(), you will find that "this" is the address of the object on the left
hand side of the member operator when whatever() was called.
</p>
So what's the use of that? Not much at first sight, because we have not introduced anything in the above example
that could not have been done with a struct. But, its the addition of the member functions that's the key here.
Our cat could be a cat in a 3D animation, that might run, jump, chase mice, and meaow. Anything the cat could do
would be done through the member functions of the cat. Our cat class could potentially have a lot more life in it
than a struct ever could have. Lets have a look at a slightly more complicated cat. Look at this one. <br/><br/>

#include  &lt iostream &gt <br/>
using namespace std;<br/>
class Cat{<br/>

&nbsp  &nbsp     private:<br/>
&nbsp  &nbsp  &nbsp  &nbsp       int age;<br/>
&nbsp  &nbsp  &nbsp  &nbsp       float weight;<br/>
 &nbsp  &nbsp  &nbsp  &nbsp      char* name;<br/>
&nbsp  &nbsp     public:<br/>
 &nbsp  &nbsp  &nbsp  &nbsp      void setage(int);<br/>
&nbsp  &nbsp  &nbsp  &nbsp       int getage();<br/>
&nbsp  &nbsp  &nbsp  &nbsp       void setweight(float);<br/>
&nbsp  &nbsp  &nbsp  &nbsp       float getweight();<br/>
&nbsp  &nbsp  &nbsp  &nbsp       void setname(const char*);<br/>
&nbsp  &nbsp  &nbsp  &nbsp       char* getname();<br/>
};<br/>
void Cat::setage(int i){<br/>
&nbsp  &nbsp     age=i;<br/>
}<br/>
int Cat::getage(){<br/>
&nbsp  &nbsp     return age;<br/>
}<br/>
void Cat::setweight(float x){<br/>
 &nbsp  &nbsp    weight=x;<br/>
}<br/>
float Cat::getweight(){<br/>
 &nbsp  &nbsp    return weight;<br/>
}<br/>
void Cat::setname(const char* this_string){<br/>
&nbsp  &nbsp  int length=strlen(this_string);<br/>
&nbsp  &nbsp  name=(char*)malloc(length*sizeof(char));<br/>
&nbsp  &nbsp  strcpy(name,this_string);<br/>
}<br/>
char* Cat::getname(){<br/>
&nbsp  &nbsp  return name;}<br/>
int main(){<br/>

&nbsp  &nbsp  Cat cat1;<br/>

&nbsp  &nbsp  cat1.setage(5);<br/>
&nbsp  &nbsp  cat1.setweight(1.3);<br/>
&nbsp  &nbsp  cat1.setname("Tiddles");<br/>

&nbsp  &nbsp  cout &lt &lt  cat1.getname()  &lt &lt "  is "  &lt &lt  cat1.getage()  &lt &lt  " years old and weighs "  &lt &lt cat1.getweight()
 &lt &lt  "  Kilos"  &lt &lt  endl;<br/>

}<br/>

Now it should be clear, the cat has public member functions or methods. all they do here is
set the cat's data, or get the cat's data, but they are examples of a cat class, with a cat object MyCat1
accessing its methods. The data is private, and can only be accessed by cats member functions.
When the member functions are defined, the name of the class, followed by a scope resolution operator ::
is used, i.e  int Cat::getage(); Member functions are always called by the name of the object, the . operator
followed by the name of the function as in iage MyCat1.getage();.

<br/>
 <a href="#start" > Back to list of contents</a>
</p>
</blockquote>
<h1 align="center"> <a name="construct" > Constructors and Destructors </a></h1>

<blockquote>
<p>

In the last example, we quite happily typed in the line Cat cat1. The compiler got it right, but mostly you need
to tell the compiler exactly how to build up the object. This is done by providing the compiler with a constructor function.
This is done via<br/><br/>
Cat::Cat(){<br/>
&nbsp  &nbsp age=1;<br/>
&nbsp  &nbsp weight=1.0;<br/>
&nbsp  &nbsp const char* tempname="Tiddles";<br/>
&nbsp  &nbsp  int length=strlen(tempname);<br/>
&nbsp  &nbsp  name=(char*)malloc(length*sizeof(char));<br/>
&nbsp  &nbsp  strcpy(name,tempname);<br/>
&nbsp  &nbsp  cout &lt &lt " A cat has been created\n";
}<br/><br/>
Cat::~Cat(){<br/>
&nbsp  &nbsp  cout &lt &lt " A cat has gone cheshire\n";<br/>
//take no action<br/>
}<br/>
<br/>
Now the cat has default initial data,  when cat1 is declared to be a cat in the main function,
the compiler sees Cat, knows Cat is a class, and looks for the Cat() constructor. If a constructor
is used, you must provide a destructor ~Cat() function. Here we take no action apart from
to notify that the cat "has gone cheshire". It will do the inverse of whatever the constructor did.
Here, any heap memory should be deleted.
</p>
<p>
There is another constructor which should be provided if ever a cat is copied. This is the copy constructor.
Here is a copy constructor for the Cat.<br/><br/>
Cat::Cat(Cat &rhs){<br/>
 &nbsp  &nbsp    age=new int;<br/>
 &nbsp  &nbsp    weight=new float;<br/>
  &nbsp  &nbsp   name=new char;<br/>
 &nbsp  &nbsp    *age=rhs.getage();<br/>
 &nbsp  &nbsp    *weight=rhs.getweight();<br/>
 &nbsp  &nbsp    name=rhs.getname();<br/>
}<br/><br/>
Note that we have changed the age and weight to pointers, and made the corresponding changes to setage
and so on. There is a trap here. If you forget to make age, weight, and name,  as objects on the heap by
using the new keyword, the programme will crash. If we make cat2 as a copy of cat 1 by using Cat cat2(cat1)
in main, the destructor function is called twice at the end, once for cat2 and once for cat1. But we only have one
destructor function, so it cannot clear up memory on the stack and the heap, it will work for one, but not the
other. So, the constructor must use heap memory as well as the copy constructor. The reason we use the new
operator for the copy constructor is that we don't want two objects pointing to the same area of memory.
This would be disastrous when either one went out of scope. This is called making a deep rather than a
shallow copy. Now we can use delete in the destructor to clear the memory for each cat's name, weight, and age.
<br/>
 <a href="#start" > Back to list of contents</a>
</p>
</blockquote>

<h1 align="center"> <a name="overload" > Overload </a></h1>
<blockquote>
<p>

In the last section we had a cat constructor function  and a cat copy constructor, both were called Cat.
One took no arguments, the other took a reference to a cat. The compiler knows that Cat() and Cat(Cat&) are
different functions. This is called overloading. Any function at all may be overloaded. As long as the argument
lists are different, you can have any number of functions with the same name. When the function is called, the
compiler knows which one is meant from the argument list used.
</p>
<p>
There is a particularly nice feature of C++ called operator overloading. Here, what an operator such as + or =
will mean depends on the objects on either side. So for instance, we could have cat3=cat1. We must provide
a function that tells the compiler what we mean when the assignment operator is used between two cats.
First, in the prototype list we add <br/>  <br/>
     Cat& operator=(const Cat &);  <br/>  <br/>

Cat& Cat::operator=(const Cat & rhs){  <br/>

&nbsp  &nbsp  if(  this == &rhs  )return *this;  <br/>

&nbsp  &nbsp   //Assumes that in cat3=cat2 both cats already exist. <br/>

 &nbsp  &nbsp  *age=rhs.getage();  <br/>
&nbsp  &nbsp   *weight=rhs.getweight();  <br/>
&nbsp  &nbsp   name=rhs.getname();  <br/>

&nbsp  &nbsp   return *this;  <br/>
}  <br/>
Note that both cats must already exist, that is their constructors must have been called. Also
note that putting Cat cat3=cat2, the compiler won't call your overloaded assignment operator.
Once cat3 exists, i.e.use  Cat Cat3; the compiler will recognise the cats on either
side of the operator. Similarly, ++, --, +, -, *, /, and [] can all be overloaded. The latter would need to be overloaded
if we want an array of Cats.  <br/>

 <a href="#start" > Back to list of contents</a>
</p>
</blockquote>
<h1 align="center"> <a name="inherit" > Inheritance and Polymorphism </a></h1>


<blockquote>
<p>
Suppose we had not started off with that class of cats, but with a general class called Creature, say.
Let's say the only properties a creature has are its age and weight. Now, we want a class called Cat, it too has
an age and a weight, but we want to add some extra properties to the cat class, for instance, a Cat can have a name.
What happens is this. Instead of the Creature classes data being private, we use the keyword <em>protected</em> instead.
This keyword means that not only can a creature's accessor functions get at the data, but so can any object which
is <em> derived from </em> the creature class. So we would have something like <br/> <br/>

class Creature<br/>
{<br/>
&nbsp &nbsp public:<br/>
&nbsp &nbsp &nbsp &nbsp Creature(); //constructor<br/>
&nbsp &nbsp  &nbsp &nbsp ~Creature(); //destructor<br/>
&nbsp &nbsp  &nbsp &nbsp int getage() const;<br/>
&nbsp &nbsp  &nbsp &nbsp int setage();<br/>
&nbsp &nbsp  &nbsp &nbsp float getweight() const;<br/>
&nbsp &nbsp  &nbsp &nbsp int setweight();<br/>
&nbsp &nbsp  &nbsp &nbsp void makenoise() const;<br/>
&nbsp &nbsp  &nbsp &nbsp void sleep();<br/>
&nbsp &nbsp  &nbsp &nbsp void move();<br/>
&nbsp &nbsp protected:<br/>
&nbsp &nbsp &nbsp &nbsp int age;<br/>
&nbsp &nbsp &nbsp &nbsp int weight;<br/>
}<br/>
class Cat : public Creature<br/>
{<br/>
&nbsp &nbsp public:<br/>
&nbsp &nbsp &nbsp &nbsp void whichmood(bool );<br/>
&nbsp &nbsp &nbsp &nbsp void makenoise(bool )
protected:<br/>
      bool angry;<br/>
}<br/> <br/>
Now, we have the class of Creature, then the Cat class, declared with the :public Creature bit.
This tells the compiler that the any Cat object <em>is</em> a creature. The Cat object now <em>
inherits</em> all the properties of being a Creature, so it has a weight and an age and can use the
setage and getage functions of a Creature. The Cat class is <em> derived</em> from the Creature class,
and because of this it can access the protected data through the Creature accessor functions.
</p>
<p>
When Cat mycat; is declared, first the Creature's constructor is called, this is the <em>base</em>
 constructor. The Cat constructor is then called which finishes the job. When the Cat object
 goes out of scope, the Cat destructor is called, then the Creature destructor. </p>

 <p>
 Now, both the Creature and the Cat classes have a makenoise function, we leave them all blank, but
 makenoise could send some kind of noise to the sound card say, whereas makenoise for the cat will
 send a hiss or a purr to the sound-card depending on the value whichmood has given to angry.
 The makenoise function in Cat is said to <em> override</em> the base classes makenoise function.
 Note that the return type and the argument list must be the same for the derived class to override
 the base classes functions. Also, if the const keyword is used, it must be used in both the derived
 and the base classes functions. When this is done, the base class function is hidden from the object.
 Then, if a Cat suddenly needs to use the base class function it would be done via mycat.Creature::makenoise()
 for instance. </p>

<p>
Some base class functions will be designed to be overridden, this is signalled using the <em>virtual </em>
keyword. Now for polymorphism. We can have a pointer to a creature being a Cat. We can put Creature* myCritter=new Cat;
This will create a new Cat on the heap, but what points to the Cat object is a pointer to a Creature. The Creatures
methods will be overridden by the Cat methods if they are declared as virtual. In fact, a function can be purely virtual,
we could have virtual void makenoise()=0. This means that the class must be derived from, and the function
<em> must </em > be overridden. <br/>

 <a href="#start" > Back to list of contents</a>
</p>
</blockquote>

<h1 align="center"> <a name="template" > Templates, a Simple Example</a></h1>

<blockquote>
<p>

We start off here with a simple error checking problem, and introduce templates. The simple error checking functions
are dealt with by a try throw catch block, first we start with a simple check for NULL pointer on an integer.
There is a test in the try block. If the test fails, then the keyword throw is used. This is given the name of
a class. If the error is thrown, control is passed to the catch part of the block and the action is taken. <br/><br/>


#include &lt iostream &gt <br/>
using namespace std;<br/>
class CMyNullCheck{<br/>
 &nbsp &nbsp    public:<br/>
&nbsp  &nbsp &nbsp &nbsp     CMyNullCheck(){}<br/>
 &nbsp &nbsp &nbsp &nbsp    ~CMyNullCheck(){}<br/>
 &nbsp &nbsp &nbsp &nbsp     void  MyCheck(int *);<br/>
};
void CMyNullCheck::MyCheck(int * i){<br/>
  &nbsp &nbsp   try{<br/>
 &nbsp &nbsp &nbsp &nbsp    if(i==NULL)throw CMyNullCheck();<br/>
  &nbsp &nbsp    }<br/>
 &nbsp &nbsp   catch(CMyNullCheck)<br/>
  &nbsp &nbsp &nbsp &nbsp   {
   &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp    cout &lt &lt  "Null pointer returned, programme failed\n";<br/>
    &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp   exit(0);<br/>
  &nbsp &nbsp    }<br/>

}<br/>
int main(){<br/>
&nbsp &nbsp CMyNullCheck kcheck;<br/>

 &nbsp &nbsp    int *i=new int;<br/>
 &nbsp &nbsp    kcheck.MyCheck(i);<br/>

 &nbsp &nbsp    cout &lt &lt " The pointer is " &lt &lt i &lt &lt  "\n";<br/>
 &nbsp &nbsp    return 0;<br/>
}<br/><br/>
Now in the main programme, we have a CMyNullCheck object kcheck which has access
to MyCheck. That's all the error checking that is seen in the main code, and the rest
could be swept away into a header file.</p>
<p>
Now as it stands, if we had a pointer to a float, or a Cat, or anything else, we would need
a different handler for each and every kind of object. But we don't! We can make this handler
a template class. Here is how it works.<br/><br/>

#include &lt iostream &gt <br/><br/>
using namespace std;<br/>

template &lt class T &gt class CMyNullCheck{<br/>
   &nbsp &nbsp       public:<br/>
    &nbsp &nbsp     CMyNullCheck(){}<br/>
     &nbsp &nbsp    ~CMyNullCheck(){}<br/>
    &nbsp &nbsp     void  MyCheck(T *);<br/>
};
template &lt class T &gt <br/>
void CMyNullCheck &lt T &gt ::MyCheck(T *i){<br/>
   &nbsp &nbsp    try{<br/>
   &nbsp &nbsp     if(i==NULL)throw CMyNullCheck();<br/>
   &nbsp &nbsp    &nbsp &nbsp     }<br/>
    &nbsp &nbsp    catch(CMyNullCheck)<br/>
    &nbsp &nbsp    {<br/>
    &nbsp &nbsp      cout &lt &lt  "Null pointer returned, programme failed\n";<br/>
    &nbsp &nbsp      exit(0);<br/>
    }<br/>

}<br/>
int main(){<br/>

  &nbsp &nbsp      typedef CMyNullCheck &lt int &gt  kCheck;<br/>
  &nbsp &nbsp      typedef CMyNullCheck &lt float &gt fCheck;<br/>
  &nbsp &nbsp      typedef CMyNullCheck &lt char &gt cCheck;<br/><br/>

 &nbsp &nbsp       kCheck kcheck;<br/>
 &nbsp &nbsp       fCheck xcheck;<br/>
 &nbsp &nbsp       cCheck acheck;<br/><br/>

  &nbsp &nbsp      int *i=new int;<br/>
  &nbsp &nbsp      float *x=new float;<br/>
  &nbsp &nbsp      char *a=new char;<br/><br/>


  &nbsp &nbsp      kcheck.MyCheck(i);<br/>
  &nbsp &nbsp      xcheck.MyCheck(x);<br/>
  &nbsp &nbsp      acheck.MyCheck(a);<br/><br/>

   &nbsp &nbsp     cout &lt &lt " The pointer is " &lt &lt i &lt &lt  "\n";<br/>
   &nbsp &nbsp     return 0;<br/>


}
<br/>
The key here is "template &lt class T &gt " in the class and function declaration. The syntax gets a bit of
getting used to. The &lt T &gt is needed in the declaration of the function, the MyCheck function now takes
a pointer to a template. Then we use typedef so that kCheck is a CMyNullCheck &lt int &gt object, so
when you declare a templated object, the compiler is told what to substitute into a template by
whatever is in the angle brackets. So now CMyNullCheck can check pointers to absolutely any
type of object.

 <br/>
 <a href="#start" > Back to list of contents</a>
</p>
</blockquote>

<h1  align="center"> <a name="Linked List" > A Linked List and Recursion </a></h1>
<blockquote>
<p>

A linked list is a simple data structure, where one piece of data points to the next. Each piece of data is
a node in the list. It starts of with a head node, pointing to a tail node. A node arrives, the head node is
made to point to it, and it is made to point to the tail node. Then as more nodes arrive we have different choices.
Say a second node arrives, we may make the head node point to it, and make it point to the first node that arrived.
Later we can insert nodes anywhere, or make structures like stacks and queues. We shall want to make a Node
class that can hold any data type, It shall need a show function and a compare function, so if you want
to have just list you would need to write a class to hold the numbers with a compare function and a show function.
We shall give an instance of a linked list here, and discuss recursion. It's not obvious where the recursion takes place in the
following. First the node class. <br/> <br/>

#include "throwcatch.h" <br/>

template &lt class T &gt <br/>
class CMyNode1{ <br/>

  &nbsp &nbsp     public: <br/>

 &nbsp &nbsp    &nbsp &nbsp        CMyNode1(); <br/>
   &nbsp &nbsp    &nbsp &nbsp      ~CMyNode1(); <br/>
  &nbsp &nbsp    &nbsp &nbsp       CMyNode1(CMyNode1 &); <br/>

  &nbsp &nbsp    &nbsp &nbsp       void SetNode(T&,CMyNode1 &); <br/>
 &nbsp &nbsp    &nbsp &nbsp        void SetNode(T*,CMyNode1 *); <br/>
 &nbsp &nbsp    &nbsp &nbsp        void SetNode(T&); <br/>
 &nbsp &nbsp    &nbsp &nbsp        void SetNode(T*); <br/>
  &nbsp &nbsp    &nbsp &nbsp       void SetNode(CMyNode1 &); <br/>
 &nbsp &nbsp    &nbsp &nbsp        void SetNode(CMyNode1 *); <br/>

  &nbsp &nbsp    &nbsp &nbsp       CMyNode1* GetNextPtr(); <br/>
  &nbsp &nbsp    &nbsp &nbsp       T* GetDatumPtr(); <br/>

  &nbsp &nbsp    &nbsp &nbsp       CMyNode1& operator=(CMyNode1&); <br/>
 &nbsp &nbsp    &nbsp &nbsp        CMyNode1* operator=(CMyNode1*); <br/>

 &nbsp &nbsp    &nbsp &nbsp        int Compare(CMyNode1 &); <br/>
  &nbsp &nbsp    &nbsp &nbsp       int Compare(CMyNode1 *); <br/>
  &nbsp &nbsp    &nbsp &nbsp       void show(); <br/>

  &nbsp &nbsp       private: <br/>

  &nbsp &nbsp    &nbsp &nbsp       CMyNode1 *ptrNode1; <br/>
  &nbsp &nbsp    &nbsp &nbsp       T*  Datum; <br/>

}; <br/>
template  &lt class T &gt <br/>
CMyNode1 &lt T &gt ::CMyNode1(){ <br/>
  &nbsp &nbsp     CMyNullCheck &lt T &gt checkit; <br/>
  &nbsp &nbsp     ptrNode1=NULL; <br/>
  &nbsp &nbsp     Datum=new T; <br/>

  &nbsp &nbsp     checkit.MyCheck(Datum); <br/>
} <br/>
template &lt class T &gt <br/>
CMyNode1 &lt T &gt ::~CMyNode1(){ <br/>
   &nbsp &nbsp      delete Datum; <br/>
   &nbsp &nbsp      Datum=NULL; <br/>
   &nbsp &nbsp      delete ptrNode1; <br/>
  &nbsp &nbsp       ptrNode1=NULL; <br/>
} <br/>
template &lt class T &gt  <br/>
CMyNode1 &lt T &gt ::CMyNode1(CMyNode1 &lt T &gt & rhs){ <br/>
 &nbsp &nbsp   CMyNullCheck &lt T &gt  checkdatum; <br/>
 &nbsp &nbsp   CMyNullCheck &lt CMyNode1 &gt checknode; <br/>
  &nbsp &nbsp    ptrNode1=new CMyNode1; <br/>
  &nbsp &nbsp    Datum=new T; <br/>
  &nbsp &nbsp    checkdatum.MyCheck(Datum); <br/>
  &nbsp &nbsp    checknode.MyCheck(ptrNode1); <br/>

 &nbsp &nbsp     ptrNode1=rhs.GetNextPtr(); <br/>
 &nbsp &nbsp     Datum=rhs.GetDatumPtr(); <br/>
}

template &lt class T &gt  <br/>
void CMyNode1 &lt T &gt ::SetNode(T& Object,CMyNode1 &lt T &gt  &Node){ <br/>
   &nbsp &nbsp       ptrNode1=&Node; <br/>
   &nbsp &nbsp       *Datum=Object; <br/>
} <br/>
template &lt class T &gt  <br/>
void CMyNode1 &lt T &gt ::SetNode(T& Object){ <br/>
   &nbsp &nbsp       *Datum=Object; <br/>
} <br/>
template &lt class T &gt <br/>
void CMyNode1 &lt T &gt ::SetNode(T* Object){ <br/>
   &nbsp &nbsp       *Datum=*Object; <br/>
} <br/>
template &lt class T &gt  <br/>
void CMyNode1 &lt T &gt ::SetNode(CMyNode1 &lt T &gt &Node){ <br/>
    &nbsp &nbsp      ptrNode1=&Node; <br/>
} <br/>
template &lt class T &gt  <br/>
void CMyNode1 &lt T &gt ::SetNode(CMyNode1 &lt T &gt *Node){ <br/>
    &nbsp &nbsp      ptrNode1=Node; <br/>
}
template &lt class T &gt  <br/>
void CMyNode1 &lt T &gt ::SetNode(T* Object,CMyNode1 &lt T &gt  *Node){ <br/>
   &nbsp &nbsp       ptrNode1=Node; <br/>
    &nbsp &nbsp      *Datum=*Object; <br/>
}
template &lt class T &gt  <br/>
CMyNode1 &lt T &gt *  CMyNode1 &lt T &gt ::GetNextPtr(){ <br/>
  &nbsp &nbsp       return ptrNode1; <br/>
}
template &lt class T &gt  <br/>
T* CMyNode1 &lt T &gt ::GetDatumPtr(){ <br/>
   &nbsp &nbsp     return Datum; <br/>
} <br/>
template &lt class T &gt <br/>
CMyNode1 &lt T &gt & CMyNode1 &lt T &gt ::operator=(CMyNode1 &lt T &gt & rhs){ <br/>
 &nbsp &nbsp   //Warning, assumes lhs exists already <br/>
 &nbsp &nbsp    if(this == &rhs)return *this; <br/>
    &nbsp &nbsp   Datum=rhs.GetDatumPtr(); <br/>
   &nbsp &nbsp   ptrNode1=rhs.GetNextPtr(); <br/>
 &nbsp &nbsp   return this; <br/>
} <br/>
template &lt class T &gt  <br/>
CMyNode1 &lt T &gt * CMyNode1 &lt T &gt ::operator=(CMyNode1 &lt T &gt* rhs){ <br/>
//Warning, assumes lhs exists already <br/>
 &nbsp &nbsp    if(this == &rhs)return *this; <br/>
 &nbsp &nbsp   Datum=rhs->GetDatumPtr(); <br/>
 &nbsp &nbsp   ptrNode1->rhs.GetNextPtr(); <br/>
 &nbsp &nbsp   return this; <br/>
} <br/>
 <br/>
template &lt class T &gt <br/>
int CMyNode1 &lt T &gt::Compare(CMyNode1 &lt T &gt* rhs){ <br/>
  &nbsp &nbsp    int i=Datum->Compare(rhs.GetDatumPtr() ); <br/>
 &nbsp &nbsp     return i; <br/>
} <br/>
template &lt class T &gt <br/>
int CMyNode1 &lt T &gt::Compare(CMyNode1 &lt T &gt& rhs){ <br/>
 &nbsp &nbsp     int i=Datum->Compare(rhs.GetDatumPtr() ); <br/>
 &nbsp &nbsp    return i; <br/>
} <br/>
template &lt class T &gt <br/>
void CMyNode1 &lt T &gt::show(){ <br/>
 <br/>
  &nbsp &nbsp      Datum->show(); <br/>

} <br/> <br/>

Now, all the node contains is a pointer to some object, and a pointer to another node. Here is a linked list class,
all it contains is a pointer to a head node and a tail node.  <br/> <br/>
#include "Node1.h" <br/>
#include "Cat.h" <br/>
template <class T> <br/>
class CMyLinkedList{ <br/>

 &nbsp &nbsp       public: <br/>
  &nbsp &nbsp    &nbsp &nbsp         CMyLinkedList(); <br/>
   &nbsp &nbsp    &nbsp &nbsp        ~CMyLinkedList(); <br/>

    &nbsp &nbsp    &nbsp &nbsp        void AddToTop(T&); <br/>
    &nbsp &nbsp    &nbsp &nbsp        void AddToTop(T*); <br/>
     &nbsp &nbsp    &nbsp &nbsp       void show(); <br/>
     &nbsp &nbsp    &nbsp &nbsp       static int GetLength(){return listlength;} <br/>
   &nbsp &nbsp     private: <br/>
    &nbsp &nbsp    &nbsp &nbsp      T*  HeadNode; <br/>
    &nbsp &nbsp    &nbsp &nbsp      T*  TailNode; <br/>
    &nbsp &nbsp    &nbsp &nbsp      static int listlength; <br/>
}; <br/>

template &lt class T &gt <br/>
int CMyLinkedList &lt T &gt::listlength=0; <br/>


template &lt class T &gt  <br/>
CMyLinkedList &lt T &gt ::CMyLinkedList(){ <br/>
  &nbsp &nbsp       HeadNode=new T; <br/>
  &nbsp &nbsp       TailNode=new T; <br/>
   &nbsp &nbsp      HeadNode->SetNode(TailNode); <br/>
} <br/>
template &lt class T &gt <br/>
CMyLinkedList &lt T &gt ::~CMyLinkedList(){ <br/>
  &nbsp &nbsp       delete HeadNode; <br/>
   &nbsp &nbsp      HeadNode=NULL; <br/>
   &nbsp &nbsp      TailNode=NULL; <br/>
} <br/>
template  &lt class T &gt <br/>
void CMyLinkedList &lt T &gt ::AddToTop(T& ToAdd){ <br/>
  &nbsp &nbsp     ToAdd.SetNode(HeadNode->GetNextPtr() ); <br/>
  &nbsp &nbsp     HeadNode->SetNode(ToAdd); <br/>
  &nbsp &nbsp     listlength++; <br/>
} <br/>
template &lt class T &gt  <br/>
void CMyLinkedList &lt T &gt ::AddToTop(T* ToAdd){ <br/>
   &nbsp &nbsp    ToAdd->SetNode(HeadNode->GetNextPtr() ); <br/>
  &nbsp &nbsp     HeadNode->SetNode(ToAdd); <br/>
  &nbsp &nbsp     listlength++; <br/>
} <br/>
template &lt class T &gt  <br/>
void CMyLinkedList &lt T &gt ::show(){ <br/>
  &nbsp &nbsp     T* TempNode; <br/>
   &nbsp &nbsp    TempNode=HeadNode; <br/>
   &nbsp &nbsp    for(int i=0; i &lt listlength;i++){ <br/>
   &nbsp &nbsp    &nbsp &nbsp       TempNode=TempNode->GetNextPtr(); <br/>
   &nbsp &nbsp    &nbsp &nbsp       TempNode->show(); <br/>
  &nbsp &nbsp     } <br/>
} <br/>
int main(){ <br/> <br/>
  &nbsp &nbsp    typedef CMyNode1<Cat>  CatNode; <br/>
 &nbsp &nbsp     typedef CMyLinkedList<CatNode> CatList; <br/>

  &nbsp &nbsp    Cat cat1; <br/>
 &nbsp &nbsp     Cat cat2; <br/>
  &nbsp &nbsp    Cat cat3; <br/>
  &nbsp &nbsp    Cat cat4; <br/>
  &nbsp &nbsp    Cat cat5; <br/>

 &nbsp &nbsp     cat1.setage(10); <br/>
 &nbsp &nbsp     cat2.setage(2); <br/>
 &nbsp &nbsp    cat3.setage(3); <br/>
  &nbsp &nbsp    cat4.setage(4); <br/>
  &nbsp &nbsp    cat5.setage(7); <br/>

  &nbsp &nbsp    CatNode *node1=new CatNode; <br/>
 &nbsp &nbsp     CatNode *node2=new CatNode; <br/>
 &nbsp &nbsp     CatNode *node3=new CatNode; <br/>
 &nbsp &nbsp     CatNode *node4=new CatNode; <br/>
 &nbsp &nbsp     CatNode *node5=new CatNode; <br/>

  &nbsp &nbsp    node1->SetNode(cat1); <br/>
  &nbsp &nbsp    node2->SetNode(cat2); <br/>
  &nbsp &nbsp    node3->SetNode(cat3); <br/>
  &nbsp &nbsp    node4->SetNode(cat4); <br/>
  &nbsp &nbsp    node5->SetNode(cat5); <br/>



  &nbsp &nbsp    CatList Moggies; <br/>

   &nbsp &nbsp   Moggies.AddToTop(node1); <br/>
  &nbsp &nbsp    Moggies.AddToTop(node2); <br/>
  &nbsp &nbsp    Moggies.AddToTop(node3); <br/>
  &nbsp &nbsp    Moggies.AddToTop(node4); <br/>
  &nbsp &nbsp    Moggies.AddToTop(node5); <br/>

  &nbsp &nbsp    Moggies.show(); <br/>
 &nbsp &nbsp   return 0; <br/>
} <br/> <br/>
Where is the recursion?  Well, five cats are declared, deep copies of these cats are stuffed into nodes,
each cat is added to the list which is  and then shown. OK, the list's show calls the node's show calls
the Datum's show, but this is function overloading not recursion. Oddly enough, the recursion is all in the
return 0; When the main function returns, all the objects on the function stack are popped off. The last thing
on the function stack was the list, so this is first. Its destructor function is called, and that says delete
the head node, that calls the node destructor, in which it says delete ptrNode1, that calls the node destructor
on whatever the headnode is pointing to, which then deletes the whatever the first node is pointing to. That delete
ptrNode1 is called recursively. Copies of each ptrNode1 are on the function stack with the data. By the time
it reaches ptrNode1 = NULL, every single node on the list is deleted. The function stack is rewound, so it returns
to ptrNode1=NULL until it's right back at the beginning and the HeadNodes ptrNode1 is NULL.

 </p><p>This kind of
thing is something to watch out for, if you had a delete TailNode, it would crash the programme when a list destructor was called.
Also, note that each node is put on the Heap using the new operator.
If it was not, there would still be trouble when the destructor was called. When delete is used on the head node, that's
fine, but then it would call delete on the next node which would be on the stack. Stack memory is managed using malloc
and free, heap memory uses new and delete, you can't call delete on stack memory, so each node must be created on the
heap using the new operator.


 <br/>
 <a href="#start" > Back to list of contents</a>
</p>
<p>
<a href="index.html"> Back Home </a>
</p>
</blockquote>

<h1 align="center"> <a name="Calling Fortran">Calling Fortran from C++ </a> </h1>
<blockquote>
<p>
Well, why on Earth would you want to do that? One of the most important reasons that there are vast repositories of
Fortran subroutines and functions such as can be found at GAMS (Guide to Applied Mathematical Software) for instance.
Try this link <a href="CompLinks.html"> Mathematical and Geometrical Software </a>.
This is a big area, and the following links contain much more information, try  
<a href="http://www.aei.mpg.de/~jthorn/c2f.html">Fortran/C 1 </a> 
and
<a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialMixingFortranAndC.html"> Fortran/C 2 </a>.  

</p>

</p>
Here we shall provide the simplest of examples. This is for calling Fortran 77 which can only be
called using the gcc-3 series. With the gcc-4 series, there is no Fortran 77. In this case you
 must use gfortran, just drop the fortran.h include line, and
the -lg2c at the compile stage. (Using gcc-3 and Fortran 77 is sometimes useful if you need to
use legacy code that include statements that are obsolete after Fortran 90.)
Suppose we have the simple subroutine listed below, it is stored in the file fortfun.f.
</p>
<p>
 &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp    subroutine FORTFUN <br/>

C   &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp      The subroutine statement is absolutely necessary <br/>
C   &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp      otherwise the C++ compiler won't know what the function <br/>
C   &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp      in fortfun.o is <br/>
C  &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp      do nm -a (Unix/linux) fortfun.o and you will see fortfun_ <br/>
C    &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp     in the list, and it won't be there without the subroutine statement. <br/>
      &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp       write(6,*)"Hello, this is a FORTRAN subroutine" <br/>
     &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp     return <br/>
     &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp     end <br/>
</p>
<p>
Now you can compile this to an object file via f77 -c fortfun.f. On a Unix/linux system you can use the
command nm -a fortfun.o on the object file, and you will find one of the names
you get is fortfun_.  You won't get that name without a subroutine or function statement at the beginning of the Fortran file, and the C++ compiler needs that name in the object file. Note that a FORTRAN subroutine is just like a C/C++ function with a void return type. Functions should be prototyped as usual. Now for the C++ calling routine saved in callfort.cpp.
</p>


<p>

 Now for the simple C++ calling routine.
</p>
<p>
#include "fortran.h"  <br/>
#include &lt iostream &gt  <br/>

using namespace std;  <br/>

extern "C" {  <br/>
void fortfun_();  <br/>
	}  <br/>

int main(){  <br/>
	cout << "Hullo, we shall call FORTRAN today\n"; <br/>

        fortfun_(); <br/>
        return 0; <br/>
} <br/>
</p>
<p>
The first include is fortran.h, and this can be obtained from the first of the Fortran/C links above. The first important
line is the "extern "C" {  //function prototype goes here }, this form must be used for any Fortran subroutine or
 function you need to call. This is system dependent, but on many systems, the subroutine/function name gets converted to 
 lower case, and the name is appended with an underscore, so FORTFUN appears as fortfun_ as far as the C/C++ calling 
program is concerned. The rest is trivial. To compile we can just do f77 -c fortfun.f and g++ -c callfort.cpp to get
the object files callfort.o and fortfun.o, and then g++ -o callfort callfort.o fortfun.o -lg2c. The -lg2c bit enables
the C++ compiler to access the Fortran libraries (well for the gnu compilers that's what you need, otherwise you have to find out). What Fortran library is being used here? Well, the write statement isn't a command as such, but a call to a Fortran function in the Fortran  I/O library. So, you need to link the lg2c library as well as the two object files.
</p>
<p>
Well, it's that simple on a Unix/Linux system using the gnu compilers, I cannot say what it's like on other systems or with 
other compilers. As for passing variables, there are differences. All Fortran programmes pass variables by reference,
however, the C/C++ compilers pass by value. So, you can't have i=fun(j,k); you need i=fun(&i, &j);, Of course
arrays are passed by reference in C/C++ anyway, so you can have i=fun(array);. Another one to watch out for is the passing of multidimensional arrays. If you print array[i][j], then call fun(array) which contains a statement write(6,*)array(i,j)
 the Fortran routine will print whatever array[j][i] is as far as the C/C++ code is concerned. Also, loops in the C/C++ routine should be the other way round that they are in the Fortran routines. Of course there is more to it than this, which is why I provided the links above.


</p>

</blockquote>
<h1 align="center"> <a name="intro"> The C++ Standard Library</a> </h1>
<blockquote>
<p>
There is a very useful and impressive set of classes and functions that come 
with C++ in the standard library. We shall mention a few instances here.
The &lt bitset &gt class is great for dealing binary, and allows you to 
set individual 
bits for instance. There double and single ended queues (&lt dqueue &gt and
 &lt queue &gt)
and other containers. The  &lt vector &gt class is essentially a dynamic array 
and is very useful.
</p>
<p>
For string and file handling, there are 
&lt fstream &gt 
and 
&lt sstream &gt
.
The latter, called string-stream works like &lt iostream &gt, and works
with  the C++ string class. You can use it's c_str() member function to
get an old C type string. You will also need &lt iomanip &gt  in
order to do things like set the precision of a number.
You can write numbers to cstring objects by doing the following.
First declare an "ostringstream", call it "xout" say. Then if
we have some number "x"  we can just use  xout &lt &lt setprecision(4) &lt &lt scientific;.  This tells xout the required format for the number. Then
 we can do xout &lt &lt x;.  To get it into a string, all we need is
 xstring &lt &lt xout.str();. Now if we need to pass a C-string
 to something (like MyFont.output(arg)), we pass xstring.c_str();.
 So, we conclude that  the C++ standard library is well worth looking
at. It could save you a lot of time and trouble.



</p>
</blockquote>
</body>
</html>
